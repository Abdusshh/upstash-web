---

title: "Get Rid of Function Timeouts and Reduce Vercel Costs"
slug: vercel-cost-workflow
draft: true
authors: [enes]
tags: [qstash, workflow, vercel]
---

Vercel is an excellent platform for hosting static sites and serverless functions. It's user-friendly and offers a free tier. However, if you're not careful, you can quickly exceed the tier limits and incur costs. In this post, I'll show you how Upstash Workflow can help manage Vercel costs, specifically function duration costs.

Vercel charges have many dimensions. Here, we will focus on costs due to serverless function execution time. This post is for you if:
-  You experience timeouts in your functions or can't run long tasks due to timeout limits in Vercel.
-  Your bill shows you exceed the tier limits for Function Duration, resulting in charges.

If your bill is high due to the number of invocations, this post may not be for you. Workflow encourages splitting functions into multiple ones, which can increase the number of invocations.

## What is Vercel Functions Duration Cost?

Vercel executes your backend logic using serverless functions on AWS Lambda. They charge users based on the number of invocations and execution time. Additionally, each Vercel plan includes a timeout for the function's duration.          
<table>
<tr>
<th>Plan </th>
<th>Default Timeout </th>
<th>Max Timeout </th>
<th>Included in Plan </th>
<th>Price for extra </th>
</tr>
<tr>
<td> Hobby </td>
<td>10 seconds </td>
<td>60 seconds </td>
<td>100 hours </td>
<td>N/A  </td>
</tr>
<tr>
<td> Pro </td>
<td>15 seconds </td>
<td>5 minutes </td>
<td>1000 hours </td>
<td>0.18 per hour  </td>
</tr>
</table>
                            

## Upstash Workflow and function duration costs
Upstash Workflow is a messaging system that helps you orchestrate serverless functions. While you still host the function code, Workflow manages their execution. It retries in case of failure and preserves the order of tasks. Another important feature is that you can offload API calls to Workflow. Instead of waiting for the API response within the function, you can delegate the API call to Workflow. After getting the API response, Workflow will retrigger the function with the response. This is particularly useful for calling long-running APIs in a serverless function, as it prevents the function from idling while waiting for the API response.
![Workflow Context Call.png](/blog/workflow/workflow.png)


In the above image, you see two ways to implement a serverless function that calls an external API. Many functions now call AI APIs, which often have long and highly variable response times. If the GPU of your inference service is busy, the response time can be very high.

In the first implementation, the function waits for the API response. In the second implementation, the function offloads the API call to Workflow. Workflow calls the API and, when the response is ready, it re-triggers the function with the response. This way, the function does not wait for the API response and does not consume the function's duration time.

In the image, the green area represents the duration Vercel charges you. In the second approach, using Upstash Workflow, the green area is smaller. As the time spent by the API call increases, the cost savings with Workflow increase.

The second approach is also more reliable. If the function fails after the API call, Workflow will retry the function. In the first approach, you need to implement the retry logic within the function.

The only drawback of the second approach is that it increases the number of invocations. The first approach makes one invocation, while the second approach makes two. If your bill is high due to the number of invocations, using  Workflow may increase it. 

## Upstash Workflow and function timeouts

Vercel imposes a timeout on function duration. If a function exceeds this timeout, Vercel terminates it. This poses a problem for long-running tasks. For instance, if you need to call an API that takes around 90 seconds to respond, you can't use Vercel's hobby plan, which has a maximum duration of 60 seconds.

![Workflow Context Call.png](/blog/workflow/workflow-timeouts.png)

The image above illustrates two approaches. The first approach runs an API call within the function, but the function is terminated because the response time exceeds the maximum timeout. The second approach offloads the API call to Workflow. Workflow calls the API and, when the response is ready, it re-triggers the function with the response. This way, the function does not wait for the API response or consume its duration time. With the second approach, you don't have to worry about function timeouts.

## What about cost of Workflow?
You can think that we are moving the cost from one bucket to another. But the good news is that Workflow charges usage per call, not per duration. We have a scheduling mechanism which is efficient enough that we do not spend resources for waiting. Each `context.call()` execution calls two QStash requests. 100,000 QStash requests cost $1.If your primary expense is function duration, using Workflow will save you money.


## Code Example

Let's implement the first approach by calling the API directly from the Next.js API route.

```javascript

export default async function handler(req, res) {
  // prepare your input data  
  const response = await fetch('https://api.example.com', {your_data});
  const data = await response.json();
  // process the response
  res.status(200).json(data);
}

```

Now let's implement the second approach, where we offload the API call to Workflow.

```javascript
import { serve } from "@upstash/qstash/nextjs"

export const POST = serve<{ topic: string }>(async (context) => {
  const request = context.requestPayload
    
  const response = await context.call( "call-api",
    "https://api.openai.com/v1/chat/completions", // Endpoint URL
     // Request body
  )
    // process the response
    await context.run("process-response", async () => {
        return someWork(response)
    })
})
   ```                       

The above is a Vercel function. When the workflow URL is first called, it executes until the `context.call()` function. Upon executing `context.call("call-api")`, the Vercel function returns, and Upstash Workflow calls the external API and awaits the response. Once the response is ready, it re-triggers the function with the response. The function then skips steps until the `context.run("process-response")` step. This approach involves executing a single function multiple times, with a different portion of the function executed each time. The advantage is that if the function calls an external API, Upstash handles this part, significantly reducing the function's execution time.             

## Conclusion

In this post, I explained how to run long-running tasks and reduce Vercel costs using Upstash Workflow. While this isn't the primary use case for Workflow, it's a valuable feature that enables you to execute time-consuming tasks on Vercel.

Thank you for reading, and [follow us on X](https://x.com/upstash) for more posts like this.



```









